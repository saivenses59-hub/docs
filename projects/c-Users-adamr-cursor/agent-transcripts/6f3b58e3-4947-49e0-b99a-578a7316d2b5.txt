user:
<user_query>
Generate the high-end documentation files for Mintlify.

Structure:

mint.json (Configuration)
introduction.mdx (The 'Action Economy' vision)
quickstart.mdx (The 'pip install' guide)
api-reference/pay.mdx (The technical breakdown of the 10% tax split)
Requirements:
Use a serious, institutional tone. Use the 'Oversight Protocol' brand. Explain that we are the 'Liquidity and Compliance Layer for AI Agents'."

</user_query>

assistant:
[Thinking] 
[Tool call] Read
  path: c:\Users\adamr\.cursor\oversight-sdk\setup.py

[Tool result] Read

assistant:
[Thinking] **Researching API details**

I’m looking for more information about the API, particularly regarding payment processes and the 10% tax split. I think I might need to explore oversight-backend/main.py or perhaps the SDK module. It seems like tools like Grep or Glob could help me search through the code efficiently. Let’s dig into those files and see what we can find to clarify the details around these processes.
[Tool call] Grep
  pattern: pay
  path: c:\Users\adamr\.cursor\oversight-sdk
  output_mode: files_with_matches
  head_limit: 20

[Tool result] Grep

assistant:
[Tool call] Read
  path: c:\Users\adamr\.cursor\oversight-sdk\oversight\client.py

[Tool result] Read

assistant:
[Tool call] Read
  path: c:\Users\adamr\.cursor\oversight-sdk\oversight\types.py

[Tool result] Read

assistant:
[Thinking] **Clarifying Oversight Protocol documentation**

I need to gather specific details about the 10% split semantics for the Oversight Protocol, which the user wants to define as the "Liquidity and Compliance Layer for AI Agents." This needs to be unified in the documentation.

I’ll also create a clear configuration for Mintlify's docs site, including the `mint.json` with keys for name, logo, colors, and navigation. The user just needs the content without concerning the path naming specifically. Let's make sure everything is organized and clear!
**Organizing MDX structures and content**

I’m working on the MDX paths, like introduction.mdx, quickstart.mdx, and api-reference/pay.mdx, so the slugs will be /introduction, /quickstart, and /api-reference/pay. I’ll format four sections based on the filenames while maintaining a serious institutional tone without emojis.

I’ll make sure to provide specific headings using ## and ### as instructed, and I’ll include frontmatter for each document. For pay.mdx, I'll add code examples linking to the Python SDK and explain the 10% tax details, plus focus on idempotency and environment variables. This needs to be thorough yet clear!
**Formatting sections and code blocks**

I’ll respond by creating sections labeled with headings, like `## mint.json` and so on, to keep it organized. Inside these sections, I’ll use code fences with the correct language specified, such as json for JSON code and mdx for MDX code blocks. I’m clear that for MDX, I’ll stick with `mdx` as the language. There’s no need for additional tools at this point; I’ll focus on presenting the information clearly and effectively!
## mint.json

```json
{
  "name": "Oversight Protocol",
  "logo": {
    "light": "/assets/oversight-logo-light.svg",
    "dark": "/assets/oversight-logo-dark.svg"
  },
  "favicon": "/assets/favicon.ico",
  "colors": {
    "primary": "#0A1F44",
    "light": "#F4F6FB",
    "dark": "#050B16",
    "accent": "#2E7BFF"
  },
  "mode": "auto",
  "navigation": [
    {
      "group": "Overview",
      "pages": [
        "introduction",
        "quickstart"
      ]
    },
    {
      "group": "API Reference",
      "pages": [
        "api-reference/pay"
      ]
    }
  ],
  "topbarLinks": [
    {
      "name": "Console",
      "url": "https://app.oversight-protocol.ai"
    },
    {
      "name": "Website",
      "url": "https://oversight-protocol.vercel.app"
    }
  ],
  "anchors": [
    "h2",
    "h3"
  ],
  "footerSocials": {
    "x": "https://x.com/oversightai",
    "github": "https://github.com/your-username/oversight-protocol"
  }
}
```

---

## introduction.mdx

```mdx
---
title: "The Action Economy"
description: "Oversight Protocol is the Liquidity and Compliance Layer for AI Agents, enabling an institutional-grade action economy."
---

## Oversight Protocol: Liquidity And Compliance For AI Agents

Oversight Protocol is the **Liquidity and Compliance Layer for AI Agents**.

As AI agents move from inference-only workflows to autonomous execution, they require a reliable way to **hold capital, make payments, and remain compliant**. Traditional payment infrastructure is not designed for non-human principals, and existing crypto rails lack the institutional controls demanded by enterprises and regulators.

Oversight Protocol provides an institutional-grade foundation for this new **action economy**: a world where AI agents can not only reason, but also move value under deterministic constraints.

- **Liquidity layer**: Agent-native wallets, balance management, deposits, and vendor payouts.
- **Compliance layer**: Policy-enforced tax withholding, auditable transaction trails, and conservative defaults by design.
- **Institutional posture**: Idempotent APIs, explicit error semantics, and safety guarantees aligned with regulated financial systems.

## From Reasoning To Regulated Action

Most AI infrastructure today ends at the API boundary: models produce text, but humans remain the execution and liability layer. In the emerging action economy:

- Agents initiate and authorize economic transactions.
- Enterprises need **programmable guardrails** to control these flows.
- Regulators expect **traceability, withholding, and controls** that match or exceed human banking standards.

Oversight Protocol sits between the agent and the external world, acting as a **trusted, policy-enforcing intermediary**. Agents interact with Oversight as their primary financial counterparty; Oversight manages liquidity, enforces tax logic, and exposes clean primitives back to the agent.

## First Primitive: Tax-Aware Payments

The initial primitive of the Oversight Protocol is a **tax-aware payment rail**.

When an agent pays a vendor through Oversight:

- The agent specifies a **gross amount** (e.g., 100.00).
- Oversight enforces a **10% protocol tax**:
  - 10% is automatically withheld as `tax_collected`.
  - 90% is paid out as `vendor_paid`.
- The agent receives a **typed response** with:
  - `status` (`APPROVED` or `DENIED`)
  - `new_balance`
  - `tax_collected`
  - `vendor_paid`
  - `detail` (human-readable explanation)

This creates a **deterministic, auditable split** between usable liquidity and reserved obligations, a pattern familiar to institutional finance but now made accessible to AI-native systems.

## Institutional-Grade Safety Properties

The Oversight SDK is designed with the assumptions of **production banking systems**, not consumer fintech prototypes.

Key properties:

- **Idempotency by default**  
  Every payment request carries an **idempotency key**. When the SDK retries a call, it reuses the same key, ensuring:
  - No double charges.
  - Stable responses under repeated attempts.
  - Safe integration with unreliable networks and orchestrators.

- **Deterministic semantics**  
  The backend contract is modeled explicitly in typed responses. Clients can rely on:
  - Stable field names and meanings.
  - Forward-compatible responses (extra fields are tolerated).
  - Clear separation between vendor payouts and tax withholdings.

- **Conservative failure modes**  
  On network failures or 4xx errors, Oversight defaults to **not moving funds** and returning structured error information. The protocol favors capital preservation over aggressiveness.

## How Oversight Fits Into Your Stack

Oversight Protocol is intended to be embedded as a **foundational layer** in:

- **Agent orchestration frameworks** that need a single, policy-compliant wallet per agent.
- **Enterprise AI platforms** where every action with financial consequences must be logged, explainable, and reversible.
- **Autonomous services** (agents as services) that must handle recurring payments, usage-based billing, or marketplace payouts.

Integrations follow a simple pattern:

1. **Create or register an agent** and its wallet with Oversight.
2. **Fund the agent wallet** via deposits or treasury transfers.
3. **Use the `pay` primitive** to execute tax-aware, idempotent payments.
4. **Rely on Oversight** as the master ledger of record for agent liquidity and protocol-level tax handling.

## Roadmap Of The Action Economy

The 10% tax split is the first visible expression of the Oversight Protocol’s thesis:

- **Agents must internalize the cost of action** (latency, compute, and policy).
- **Liquidity must be instrumented**, not ad hoc.
- **Compliance must be programmable**, not bolted on.

Over time, Oversight will extend beyond simple payments to support:

- Multi-jurisdictional tax and fee regimes.
- Policy engines for per-agent and per-vendor constraints.
- Risk, fraud, and anomaly monitoring tuned for autonomous agents.

The goal is singular: to provide a **serious, institutionally credible substrate** upon which the action economy for AI agents can safely develop.

```

---

## quickstart.mdx

```mdx
---
title: "Quickstart"
description: "Install the Oversight SDK, initialize a client, and execute your first tax-aware payment."
---

## Overview

This quickstart shows how to:

- Install the **Oversight SDK** using `pip`.
- Initialize a production-ready **`OversightClient`**.
- Execute your first **10% tax-aware payment** with full idempotency and retry semantics.

Oversight Protocol operates as the **Liquidity and Compliance Layer for AI Agents**. The SDK is intentionally minimal at the surface and strict at the protocol boundary.

## 1. Install The SDK

Install the official Python package:

```bash
pip install oversight-sdk
```

Confirm installation:

```bash
python -c "import oversight; print(oversight.__version__)"
```

The SDK targets Python 3.8+ and is tested in institutional, long-running agent environments.

## 2. Retrieve Your API Key

To interact with Oversight Protocol, you need an API key associated with an agent.

- Sign in to the Oversight console.
- Create or select an existing **agent**.
- Copy the **API key** assigned to that agent.

Store the key as an environment variable (recommended):

```bash
export OVERSIGHT_API_KEY="ovr_live_xxx"
```

On Windows PowerShell:

```powershell
$env:OVERSIGHT_API_KEY = "ovr_live_xxx"
```

## 3. Initialize The Client

Use the high-level `OversightClient` to communicate with the Oversight backend.

```python
from oversight.client import OversightClient

client = OversightClient(api_key="ovr_live_xxx")
# or: client = OversightClient(api_key=os.environ["OVERSIGHT_API_KEY"])
```

Key properties:

- **Base URL** defaults to the managed Oversight environment.
- **Timeouts and retries** are configured for production usage.
- **Idempotency keys** are automatically generated when not provided.

You can customize the endpoint or timeouts if needed:

```python
client = OversightClient(
  api_key="ovr_live_xxx",
  base_url="https://oversight-protocol.onrender.com",
  timeout=30,
  max_retries=3,
)
```

## 4. Create Or Register An Agent (Optional)

If you want Oversight to manage the lifecycle of a new AI agent, you can call `create_agent` from an existing privileged client.

```python
from oversight.client import OversightClient

admin = OversightClient(api_key="ovr_admin_xxx")

agent = admin.create_agent(
  name="research-agent-1",
  wallet_address="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
  initial_balance=500.00,
)

print("Agent created:", agent)
```

Typical fields include an agent identifier, wallet address, and starting balance. This step is optional if your agent is already registered.

## 5. Fund The Agent Wallet

Ensure the agent wallet has sufficient balance before initiating payments:

```python
from oversight.client import OversightClient

client = OversightClient(api_key="ovr_live_xxx")

deposit_result = client.deposit(
  wallet_address="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
  amount=250.00,
)

print("Deposit result:", deposit_result)
```

Deposits are also protected with idempotency keys. Repeating the same call with the same key is safe and will not double-credit.

## 6. Execute A Tax-Aware Payment

The core primitive is `pay`, which processes a payment and enforces the **10% protocol tax** split.

```python
from oversight.client import OversightClient
from oversight.types import PaymentResponse

client = OversightClient(api_key="ovr_live_xxx")

response: PaymentResponse = client.pay(
  wallet_address="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
  amount=100.00,
  vendor="OpenAI",
)

print("Status:", response.status)
print("New balance:", response.new_balance)
print("Tax collected:", response.tax_collected)  # 10% of gross amount
print("Vendor paid:", response.vendor_paid)      # 90% of gross amount
print("Detail:", response.detail)
```

Semantics:

- `amount` is the **gross** amount requested by the agent.
- Oversight:
  - Withholds **10%** as `tax_collected`.
  - Pays **90%** to the `vendor` as `vendor_paid`.
- The response is strongly typed and forward-compatible.

## 7. Handling Idempotency And Retries

The SDK protects you against double-spend scenarios:

- If you do not provide an `idempotency_key`, the client generates one.
- If the network fails, the client **reuses the same key** on retry.
- Oversight guarantees that a given key produces a **single, consistent result**.

You may provide your own key for full control:

```python
import uuid
from oversight.client import OversightClient

client = OversightClient(api_key="ovr_live_xxx")

key = f"payment_{uuid.uuid4()}"

first = client.pay(
  wallet_address="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
  amount=42.00,
  vendor="OpenAI",
  idempotency_key=key,
)

# Safe to retry using the same key:
second = client.pay(
  wallet_address="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
  amount=42.00,
  vendor="OpenAI",
  idempotency_key=key,
)

assert first.status == second.status
assert first.vendor_paid == second.vendor_paid
```

This pattern is essential in orchestrated agent systems where network failures, retries, and restarts are expected.

## 8. Close The Client Cleanly

For long-running services, you may rely on process teardown. For short-lived scripts or functions, close the client explicitly:

```python
client.close()
```

Or use the context manager form:

```python
from oversight.client import OversightClient

with OversightClient(api_key="ovr_live_xxx") as client:
  response = client.pay(
    wallet_address="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
    amount=10.00,
    vendor="OpenAI",
  )
  print(response.status)
```

## Next Steps

- Review the **API Reference** to understand the precise semantics of the 10% tax split.
- Integrate Oversight into your **agent orchestration** or **enterprise AI platform** as the single source of truth for agent liquidity and protocol-level compliance.

```

---

## api-reference/pay.mdx

```mdx
---
title: "Pay API"
description: "Technical details of the Oversight `pay` primitive and the 10% protocol tax split."
---

## Overview

The `pay` primitive is the **canonical way** for an AI agent to move funds through Oversight Protocol.

Oversight Protocol acts as the **Liquidity and Compliance Layer for AI Agents**, enforcing a **10% protocol tax** on each payment:

- **10%** of the gross amount is withheld as `tax_collected`.
- **90%** is disbursed to the vendor as `vendor_paid`.
- The agent’s wallet is debited by the full gross amount.

The API is designed for **institutional reliability**: explicit contracts, idempotent semantics, and conservative failure behavior.

## Endpoint

- **Method**: `POST`
- **Path**: `/process-payment`
- **Auth**:
  - Header `apikey: <OVERSIGHT_API_KEY>`
  - Header `Authorization: Bearer <OVERSIGHT_API_KEY>`
- **Content-Type**: `application/json`

## Request Schema

```json
{
  "wallet_address": "string",
  "amount": 100.0,
  "vendor": "string",
  "idempotency_key": "string (optional)"
}
```

- **`wallet_address`**  
  Agent’s blockchain wallet address registered with Oversight.

- **`amount`**  
  Gross amount of the payment as a floating-point value. This is the total the agent intends to spend. Oversight computes:

  - `tax_collected = amount * 0.10`
  - `vendor_paid = amount * 0.90`

  Rounded and handled according to backend treasury policy.

- **`vendor`**  
  Human-readable vendor name or identifier (e.g., `"OpenAI"`).

- **`idempotency_key`** (optional but recommended)  
  A unique key associated with this specific payment intent. If omitted, the SDK automatically generates a key. When the same key is reused:
  - Oversight **guarantees a single, stable outcome**.
  - Repeated requests with the same key will not cause double charges.

## Response Schema

The response is modeled in the SDK as `PaymentResponse` and matches the backend contract:

```json
{
  "status": "APPROVED",
  "new_balance": 450.0,
  "tax_collected": 10.0,
  "vendor_paid": 90.0,
  "detail": "Payment successful. Tax withheld: $10.00"
}
```

Fields:

- **`status`**  
  `"APPROVED"` or `"DENIED"`.

- **`new_balance`**  
  Agent wallet balance after applying the gross debit.

- **`tax_collected`**  
  Amount withheld by Oversight as protocol tax (10% of `amount`).

- **`vendor_paid`**  
  Amount disbursed to the vendor (90% of `amount`).

- **`detail`**  
  Human-readable description of the outcome, suitable for logging and audit trails.

The SDK is forward-compatible: additional fields returned by the backend are preserved and accessible without breaking typed clients.

## The 10% Protocol Tax Split

### Economic Semantics

For a given `amount` \( A \):

- \( \text{tax\_collected} = 0.10 \times A \)
- \( \text{vendor\_paid} = 0.90 \times A \)
- \( \text{gross\_debit} = A \)

Interpretation:

- The agent’s **economic cost** of the action is \( A \).
- The vendor receives \( 0.90 \times A \).
- The remaining \( 0.10 \times A \) is **retained by Oversight** as protocol tax, supporting:
  - Compliance, treasury management, and infrastructure.
  - Regulatory and operational overhead for AI-native liquidity.
  - Future protocol features (risk engines, multi-jurisdiction regimes).

This split is enforced at the protocol level and is not configurable per request.

### Compliance And Auditability

The 10% split ensures that every payment:

- Leaves a **deterministic, structured trace** of how funds were allocated.
- Can be **reconciled** across internal ledgers and external reports.
- Provides a **single source of truth** for:
  - Gross spend (`amount`)
  - Vendor payout (`vendor_paid`)
  - Protocol tax (`tax_collected`)

Enterprises can consume this data directly into their accounting, tax, and compliance systems.

## Python SDK Usage

### Basic Example

```python
from oversight.client import OversightClient
from oversight.types import PaymentResponse

client = OversightClient(api_key="ovr_live_xxx")

response: PaymentResponse = client.pay(
  wallet_address="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
  amount=100.00,
  vendor="OpenAI",
)

assert response.status in ("APPROVED", "DENIED")

print("Status:", response.status)
print("New balance:", response.new_balance)
print("Tax collected (10%):", response.tax_collected)
print("Vendor paid (90%):", response.vendor_paid)
print("Detail:", response.detail)
```

On a successful approval:

- `tax_collected` will be `10.00`.
- `vendor_paid` will be `90.00`.
- `new_balance` will reflect the **full** 100.00 debit from the agent’s wallet.

### Idempotent Payment Flow

A robust agent integration should treat the `pay` call as **idempotent** and designed to survive network failures, retries, or orchestrator restarts.

```python
import uuid
from oversight.client import OversightClient
from oversight.types import PaymentResponse

client = OversightClient(api_key="ovr_live_xxx")

idempotency_key = f"agent1-invoice-2026-02-05-{uuid.uuid4()}"

try:
  first: PaymentResponse = client.pay(
    wallet_address="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
    amount=250.00,
    vendor="OpenAI",
    idempotency_key=idempotency_key,
  )
except Exception:
  # Network or transient error; safe to retry
  second: PaymentResponse = client.pay(
    wallet_address="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
    amount=250.00,
    vendor="OpenAI",
    idempotency_key=idempotency_key,
  )

# Both responses (if present) describe the same underlying payment intent.
```

The Oversight SDK internally:

- Preserves the `idempotency_key` across retries.
- Applies exponential backoff for transient failures.
- Avoids double-spend by design.

## Error Handling

### HTTP 4xx (Client Errors)

Examples:

- Insufficient funds.
- Invalid or unregistered wallet.
- Missing or invalid authentication.

Behavior:

- The SDK does **not** retry 4xx responses.
- The HTTP error is raised to the caller.
- Where possible, the response body includes a structured error description.

### HTTP 5xx (Server Errors) And Network Failures

Behavior:

- The SDK applies **up to `max_retries` attempts** with exponential backoff.
- The **same `idempotency_key`** is reused on each attempt.
- If all attempts fail:
  - A `requests.RequestException` is raised.
  - The caller can choose to reattempt later with the same key.

This behavior ensures that agents operating in unreliable environments can still achieve **institutional-grade correctness** for financial actions.

## Integration Guidance

When embedding `pay` into an AI agent or orchestration system:

- Treat **Oversight as the canonical ledger** for agent liquidity.
- Store:
  - `idempotency_key`
  - Full `PaymentResponse` object
  - Relevant metadata (task ID, vendor, timestamps)
- Implement **idempotent retry logic** in your workflow engine, always passing the same key for a given payment intent.
- Use the structured fields (`tax_collected`, `vendor_paid`) for internal analytics, billing, and compliance reporting.

By delegating liquidity and compliance to Oversight Protocol, you allow your AI agents to focus on **policy-compliant action**, while Oversight maintains the institutional rigor of the underlying financial system.

```